---
title: Dynamic Programming
author: Bhoomeendra 
date: 2023-07-25
category: Jekyll
layout: post
---

## Basic Concepts

## Problems

### Target Sum
[Problem](https://leetcode.com/problems/target-sum/) Find the number of ways to reach target sum by adding or subtracting the numbers in the array all the elements should be used only ones.<br><br>

**Learning:** The most important point here is that we can use dp over the sum as well . Intially we might feel that sum is unbounded but our algorithms complexity will depend on the sum. So we make a dp of size 2*sum+1 rows and n+1 columns. Now index i,j represet that how many solution do we have to reach sum i with first j element of the array. The other important thing is that at any instant we only need 2 columns of the dp array. So we can optimize the space complexity to O(sum).<br><br>

**Solution:** [Code](https://leetcode.com/problems/target-sum/submissions/1003537035/)

### Coin Change

[Problem](https://leetcode.com/problems/coin-change/) Find the minimum number of coins required to make the sum. We can use the same coin infinite times.<br><br>

**Learning:** Start by modeling the problem as a backtracking problem. Let's say we start with amount x and we have d unique coin denominations. So to make x at first stage we have d choices and for each choice we have to make x-c[i] where c[i] is the coin denomination. So we can see that this problem has overlapping subproblems. So we can use dp to solve this problem. We can use a 1D dp array of size x+1. dp[i] will store the minimum number of coins required to make sum i. So we can write the recurrence as dp[i] = min(dp[i],dp[i-c[j]]+1) where j varies from 0 to d-1. We can see that we are using the previous values of dp array to calculate the current value. So we can optimize the space complexity to O(x). Initilize the dp array with large values also corner cases when i-c[j] <=0  <br><br>

### House Robber

[Problem](https://leetcode.com/problems/house-robber/) Given an array of non-negative integers representing the amount of money of each house. If you rob two adjacent houses then you will be caught. Find the maximum amount of money you can rob.<br><br>

**Learning:**  We can directly think of a Dynamic programing solution for this question. Let say are at index i and we have to decide whether to rob this house or not. To do that should we need to know the maximum amount of money we can rob from the previous houses. So we can use a dp array of size n+1 where dp[i] will store the maximum amount of money we can rob from the first i houses. So we can write the recurrence as dp[i] = max(dp[i-1],dp[i-2]+nums[i]). We can see that we are using only 2 previous values of dp array to calculate the current value. So we can optimize the space complexity to O(1).<br><br>

### House Robber II

[Problem](https://leetcode.com/problems/house-robber-ii/) Given an array of non-negative integers representing the amount of money of each house. If you rob two adjacent houses then you will be caught. Find the maximum amount of money you can rob. The only difference from the previous problem is that the houses are arranged in a circle.<br><br>

**Learning:** The ideas here is to break the circle and make it into a line. So we can break the circle at index 0 and index n-1. So we can solve the problem for the first n-1 houses and for the last n-1 houses and take the maximum of the two will be our anser.<br><br>

### Maximum Subarray

[Problem](https://leetcode.com/problems/maximum-subarray/) Given an array of integers find the maximum sum of a subarray.<br><br>

**Learning:** We can directly think of a Dynamic programing solution for this question. Let say are at index i and we have to decide whether to include this element in the subarray or not. To do that should we need to know the maximum sum of a subarray ending at index i-1. So we can use a dp array of size n+1 where dp[i] will store the maximum sum of a subarray ending at index i. So we can write the recurrence as dp[i] = max(dp[i-1]+nums[i],nums[i]). We can see that we are using only 1 previous value of dp array to calculate the current value. So we can optimize the space complexity to O(1).<br><br>



